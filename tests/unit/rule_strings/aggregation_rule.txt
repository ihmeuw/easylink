
def get_aggregation_inputs_foo_rule_main_output(wildcards):
    checkpoint_file = "this/is/the/checkpoint.txt"
    if not os.path.exists(checkpoint_file):
        output, _ = checkpoints.split_some_split_node_some_split_slot.rule.expand_output(wildcards)
        raise IncompleteCheckpointException(checkpoints.split_some_split_node_some_split_slot.rule, checkpoint_target(output[0]))
    checkpoint_output = glob.glob(f"{checkpoints.split_some_split_node_some_split_slot.get(**wildcards).output.output_dir}/*/")
    chunks = [Path(filepath).parts[-1] for filepath in checkpoint_output]
    return expand(
        "these/are/processed/{chunk}",
        chunk=chunks
    )
rule:
    name: "aggregate_foo_rule_main_output"
    input: get_aggregation_inputs_foo_rule_main_output
    output: ['some/path/to/results/result.parquet']
    localrule: True
    message: "Aggregating foo_rule main_output"
    run:
        aggregator_utils._dummy_aggregator(
            input_files=list(input),
            output_filepath="some/path/to/results/result.parquet",
        )